// Code generated by MockGen. DO NOT EDIT.
// Source: ./pkg/scopehandler/handler.go

// Package mockscopehandler is a generated GoMock package.
package mockscopehandler

import (
	context "context"
	reflect "reflect"

	v1alpha1 "github.com/traas-stack/chaosmeta/chaosmeta-inject-operator/api/v1alpha1"
	model "github.com/traas-stack/chaosmeta/chaosmeta-inject-operator/pkg/model"
	gomock "github.com/golang/mock/gomock"
)

// MockScopeHandler is a mock of ScopeHandler interface.
type MockScopeHandler struct {
	ctrl     *gomock.Controller
	recorder *MockScopeHandlerMockRecorder
}

// MockScopeHandlerMockRecorder is the mock recorder for MockScopeHandler.
type MockScopeHandlerMockRecorder struct {
	mock *MockScopeHandler
}

// NewMockScopeHandler creates a new mock instance.
func NewMockScopeHandler(ctrl *gomock.Controller) *MockScopeHandler {
	mock := &MockScopeHandler{ctrl: ctrl}
	mock.recorder = &MockScopeHandlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScopeHandler) EXPECT() *MockScopeHandlerMockRecorder {
	return m.recorder
}

// CheckAlive mocks base method.
func (m *MockScopeHandler) CheckAlive(ctx context.Context, injectObject model.AtomicObject) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckAlive", ctx, injectObject)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckAlive indicates an expected call of CheckAlive.
func (mr *MockScopeHandlerMockRecorder) CheckAlive(ctx, injectObject interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckAlive", reflect.TypeOf((*MockScopeHandler)(nil).CheckAlive), ctx, injectObject)
}

// ConvertSelector mocks base method.
func (m *MockScopeHandler) ConvertSelector(ctx context.Context, spec *v1alpha1.ExperimentSpec) ([]model.AtomicObject, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConvertSelector", ctx, spec)
	ret0, _ := ret[0].([]model.AtomicObject)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConvertSelector indicates an expected call of ConvertSelector.
func (mr *MockScopeHandlerMockRecorder) ConvertSelector(ctx, spec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertSelector", reflect.TypeOf((*MockScopeHandler)(nil).ConvertSelector), ctx, spec)
}

// ExecuteInject mocks base method.
func (m *MockScopeHandler) ExecuteInject(ctx context.Context, injectObject model.AtomicObject, UID string, expArgs *v1alpha1.ExperimentCommon) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteInject", ctx, injectObject, UID, expArgs)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteInject indicates an expected call of ExecuteInject.
func (mr *MockScopeHandlerMockRecorder) ExecuteInject(ctx, injectObject, UID, expArgs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteInject", reflect.TypeOf((*MockScopeHandler)(nil).ExecuteInject), ctx, injectObject, UID, expArgs)
}

// ExecuteRecover mocks base method.
func (m *MockScopeHandler) ExecuteRecover(ctx context.Context, injectObject model.AtomicObject, UID, backup string, expArgs *v1alpha1.ExperimentCommon) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteRecover", ctx, injectObject, UID, backup, expArgs)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExecuteRecover indicates an expected call of ExecuteRecover.
func (mr *MockScopeHandlerMockRecorder) ExecuteRecover(ctx, injectObject, UID, backup, expArgs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteRecover", reflect.TypeOf((*MockScopeHandler)(nil).ExecuteRecover), ctx, injectObject, UID, backup, expArgs)
}

// GetInjectObject mocks base method.
func (m *MockScopeHandler) GetInjectObject(ctx context.Context, exp *v1alpha1.ExperimentCommon, objectName string) (model.AtomicObject, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetInjectObject", ctx, exp, objectName)
	ret0, _ := ret[0].(model.AtomicObject)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetInjectObject indicates an expected call of GetInjectObject.
func (mr *MockScopeHandlerMockRecorder) GetInjectObject(ctx, exp, objectName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInjectObject", reflect.TypeOf((*MockScopeHandler)(nil).GetInjectObject), ctx, exp, objectName)
}

// QueryExperiment mocks base method.
func (m *MockScopeHandler) QueryExperiment(ctx context.Context, injectObject model.AtomicObject, UID, backup string, expArgs *v1alpha1.ExperimentCommon, phase v1alpha1.PhaseType) (*model.SubExpInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryExperiment", ctx, injectObject, UID, backup, expArgs, phase)
	ret0, _ := ret[0].(*model.SubExpInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryExperiment indicates an expected call of QueryExperiment.
func (mr *MockScopeHandlerMockRecorder) QueryExperiment(ctx, injectObject, UID, backup, expArgs, phase interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryExperiment", reflect.TypeOf((*MockScopeHandler)(nil).QueryExperiment), ctx, injectObject, UID, backup, expArgs, phase)
}
